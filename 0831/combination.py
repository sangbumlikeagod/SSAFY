# return_lst = []
# def ncr(n, r):
#     if r == 0:
#         return_lst.append(tr[:])
#     elif n < r:
#         return 
#     else:
#         tr[r-1] = a[n-1]
#         ncr(n-1, r-1)
#         ncr(n-1, r)

# N = 10
# R = 3
# a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# tr = [0] * R
# ncr(N, R)
# print(return_lst)
# 재귀로 해결하는 경우 
'''
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
'''

# 부분집합 만들기

def subset(i, N):
    if i == N:
        s = 0
        for j in range(N):
            if bit[j]:
                s += arr[j]
        if s == 0:
            for j in range(N):
                if bit[j]:
                    print(arr[j], end = ' ')
            print()
    else:
        bit[i] = 1
        subset(i + 1, N)
        bit[i] = 0
        subset(i + 1, N)
    return 
arr = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
N = len(arr)
# 지금 부분집합을 만드는데 경직돼있음 내가 더 유연하고 다양하게 풀어야함 
bit = [0] * N

subset(0, N)
print(bit)

#비트를 이용한 방법 부분 부분 